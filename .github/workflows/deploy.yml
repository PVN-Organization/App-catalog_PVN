name: Deploy Catalog App to Production

on:
  push:
    branches: [ main, master ]
  pull_request:
    branches: [ main, master ]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'production'
        type: choice
        options:
        - production
        - staging

env:
  CONTAINER_NAME: catalog-app
  PORT: 10002
  IMAGE_TAG: catalog-app-${{ github.sha }}

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'
        
    - name: Install dependencies
      run: npm install --legacy-peer-deps
      
    - name: Run tests (if any)
      run: npm test --if-present
      
    - name: Build application
      run: npm run build

  build-and-deploy:
    needs: test
    runs-on: [self-hosted, ATM-5500721-01]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up environment variables
      run: |
        echo "DEPLOY_TIMESTAMP=$(date '+%Y%m%d_%H%M%S')" >> $GITHUB_ENV
        echo "BACKUP_NAME=catalog-app-backup-$(date '+%Y%m%d_%H%M%S')" >> $GITHUB_ENV
        
    - name: Create backup of current deployment
      run: |
        # Backup current container if exists
        if docker ps -a --format 'table {{.Names}}' | grep -q "^${{ env.CONTAINER_NAME }}$"; then
          echo "Creating backup of current deployment..."
          docker commit ${{ env.CONTAINER_NAME }} ${{ env.BACKUP_NAME }} || true
          docker save ${{ env.BACKUP_NAME }} > /tmp/${{ env.BACKUP_NAME }}.tar || true
        fi
        
    - name: Stop existing container
      run: |
        echo "Stopping existing container..."
        docker stop ${{ env.CONTAINER_NAME }} || true
        docker rm ${{ env.CONTAINER_NAME }} || true
        
    - name: Build new Docker image
      run: |
        echo "Building Docker image..."
        docker build -t ${{ env.IMAGE_TAG }} .
        
    - name: Run new container
      run: |
        echo "Starting new container..."
        docker run -d \
          --name ${{ env.CONTAINER_NAME }} \
          --restart unless-stopped \
          -p ${{ env.PORT }}:${{ env.PORT }} \
          -e NODE_ENV=production \
          -e DEPLOY_VERSION=${{ github.sha }} \
          -e DEPLOY_TIME=${{ env.DEPLOY_TIMESTAMP }} \
          ${{ env.IMAGE_TAG }}
          
    - name: Wait for application to start
      run: |
        echo "Waiting for application to start..."
        for i in {1..30}; do
          if curl -f http://localhost:${{ env.PORT }}/health >/dev/null 2>&1; then
            echo "‚úÖ Application is healthy!"
            break
          fi
          if [ $i -eq 30 ]; then
            echo "‚ùå Health check failed after 30 attempts"
            # Rollback if health check fails
            docker stop ${{ env.CONTAINER_NAME }} || true
            docker rm ${{ env.CONTAINER_NAME }} || true
            if [ -f "/tmp/${{ env.BACKUP_NAME }}.tar" ]; then
              echo "Rolling back to previous version..."
              docker load < /tmp/${{ env.BACKUP_NAME }}.tar
              docker run -d --name ${{ env.CONTAINER_NAME }} --restart unless-stopped -p ${{ env.PORT }}:${{ env.PORT }} ${{ env.BACKUP_NAME }}
            fi
            exit 1
          fi
          echo "‚è≥ Health check attempt $i/30..."
          sleep 2
        done
        
    - name: Verify deployment
      run: |
        echo "Verifying deployment..."
        
        # Check container status
        docker ps --filter "name=${{ env.CONTAINER_NAME }}" --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        
        # Check application response
        response=$(curl -s http://localhost:${{ env.PORT }}/health)
        if [ "$response" = "healthy" ]; then
          echo "‚úÖ Deployment verification successful!"
        else
          echo "‚ùå Deployment verification failed!"
          exit 1
        fi
        
    - name: Clean up old images
      run: |
        echo "Cleaning up old images..."
        # Keep only the latest 3 images
        docker images --format "table {{.Repository}}\t{{.Tag}}\t{{.CreatedAt}}" | grep "catalog-app-" | tail -n +4 | awk '{print $1":"$2}' | xargs -r docker rmi || true
        
        # Clean up backup files older than 7 days
        find /tmp -name "catalog-app-backup-*.tar" -mtime +7 -delete || true
        
        # Prune unused images
        docker image prune -f
        
    - name: Send deployment notification
      if: always()
      run: |
        if [ "${{ job.status }}" = "success" ]; then
          echo "üéâ Deployment successful!"
          echo "üì± Application URL: http://171.244.49.215:${{ env.PORT }}"
          echo "üîç Health check: http://171.244.49.215:${{ env.PORT }}/health"
          echo "üìä Container: ${{ env.CONTAINER_NAME }}"
          echo "üè∑Ô∏è Version: ${{ github.sha }}"
          echo "‚è∞ Deploy time: ${{ env.DEPLOY_TIMESTAMP }}"
        else
          echo "‚ùå Deployment failed!"
          echo "üìã Check logs: docker logs ${{ env.CONTAINER_NAME }}"
        fi
